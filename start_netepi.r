###############################################################
# Starting script to the module 'Network models of epidemics' #
###############################################################

########################
# FUNCTION DEFINITIONS
########################

# generate.network.ER <- function(N, con)
# Use: generates a random network with edges generated between all pairs of nodes with equal probability. (i.e. an Erdős-Rényi random graph)
# Input: 
#      N: the number of nodes in the network
#      con: connectivity; the probability that a pair of nodes will be connected by an edge (constant for all pairs)
# Output:
#      A: an adjacency matrix

generate.network.ER <- function(N,con){
    A <- matrix(0,ncol=N,nrow=N) # initialize with zeros
    A[upper.tri(A)] <- rbinom(N*(N-1)/2,1,con) # fill up the upper triangle
    A[lower.tri(A)] <- t(A)[lower.tri(A)] # fill up the lower triangle to obtain a symmetric matrix
    A
}


# generate.network.B <- function(N, links.per.step)
# Use: generates a random network by adding nodes one by one and linking the new nodes to old ones such that old nodes with more existing links
#      are more likely to receive the new links (preferential attachment). This is simple example of a Barabási random graph.
# Input: 
#      N: the number of nodes in the network to be generated
#      links.per.step: the number of new links to be added after each node
# Output:
#      L: a 2-column matrix of all links with each row defining one link (i.e. incidence list). Each link occurs only once.

generate.network.B <- function(N,links.per.step){
    L <- matrix(nrow=0,ncol=2) # initialize matrix with zero rows
    deg <- integer(N) # initialize vector for degrees of the nodes
    for (i in 2:N) { # note that we start assigning edges from the second node only
      n.new <- min(links.per.step,i-1) # this is needed because at the beginning there might be too few old nodes to select from
    	linkto <- sample(i-1,n.new,prob=deg[1:(i-1)]+1) # in this example, the "attractiveness of isolated nodes is 1, and it increases linearly with degree
    	newlinks <- cbind(rep(i,n.new),linkto)
    	L <- rbind(L,newlinks) # append the new links to the matrix of all links
      deg[i] = deg[i] + n.new
      deg[linkto] = deg[linkto]+1
    }
    colnames(L) <- NULL # remove the column name automatically added by cbind
    L
}

################
# Main Program #
################

library(igraph) # load the igraph package (needs to be installed in R before use)

# A small tour of some graphs and useful functions
###################################################

# An Erdős-Rényi graph

ER <- generate.network.ER(10,0.6) # generate adjacency matrix for a random Erdős-Rényi network with 10 nodes
ER # have a look at the matrix
rowSums(ER) # find the degrees of the nodes
sum(ER)/2 # the total number of links

ER.igraph <- graph.adjacency(ER,mode="upper")  # make a copy in igraph format, to be able to use igraph functions
summary(ER.igraph)
# degree() and degree.distribution() are functions in the igraph package
degree(ER.igraph)
plot(0:max(degree(ER.igraph)),degree.distribution(ER.igraph),xlab="degree",ylab="p",main="Probability distribution of node degrees")
plot(ER.igraph,main="A random Erdos-Renyi graph")  # plot the graph
# Note that the layout is generated by a heuristic algorithm, and changes with each plotting of the same graph

# A Barabási graph

B <- generate.network.B(50,3)
B # have a look at the edge list
B.igraph <- graph.edgelist(B,directed=FALSE)
summary(B.igraph)
degree(B.igraph)
plot(0:max(degree(B.igraph)),degree.distribution(B.igraph),xlab="degree",ylab="p",main="Frequency distribution of node degrees")

plot(B.igraph, main="A random Barabasi graph")

# if you continue this session and would like to plot into unsplit windows, open a new window or re-set 'par(mfrow=c(1,1))'

# A simple epidemics
####################

# over a Barabási graph, with no recovery

N = 30 # number of individuals
simlength <- 15 # number of time steps
p.t <- 0.2 # probability of transmitting the disease along a link in one time step

plot.spread <- TRUE # switch to set whether you would like to plot the spreading of the epidemic over the network (slows down the simulation when TRUE)

links <- generate.network.B(N,2) # generate an edge list for a Barabási graph

infected <- logical(N) # initialize infection status
patientzero <- sample(N,1) # select 'patient zero'
infected[patientzero] <- TRUE

if (plot.spread) {
	network.i <- graph.edgelist(links,directed=FALSE)
	fixlayout <- layout.kamada.kawai(network.i)  # store a fixed layout for the graph
	node.colour <- rep("SkyBlue2",N) # initialize node colours (SkyBlue2 is also the default node colour in igraph)
    node.colour[patientzero] <- "red" # infected nodes will be coloured red
	plot(network.i,layout=fixlayout, main="Time = 0", vertex.color=node.colour)
	}

for (i in 1:simlength) {
	discordant.links <- which(xor(infected[links[,1]],infected[links[,2]])) # find the indeces of links that connect an infected individual to an uninfected
	transmit <- rbinom(length(discordant.links),1,p.t) # determine randomly which of the discordant links transmit the disease
	# let me update the infection vector in three steps to make it easier to read:
	transmitter.links <- discordant.links[transmit==1]
	nodes.of.transmitter.links <- unique(as.vector(links[transmitter.links,1:2])) # gets both nodes of the transmitter links into a single vector; unique just filters out repetitions
	infected[nodes.of.transmitter.links] <- TRUE # here I simply set both nodes to TRUE (although the transmitter already had 'TRUE'). In more complex models, you might want to do a further check here and overwrite only the newly infected nodes.
	if (plot.spread) {
    node.colour[infected] <- "red"
#    readline() # waits for the user to press <ENTER> before proceeding; you need to switch to the console to do this
    plot(network.i,layout=fixlayout, main=paste("Time =", i), vertex.color=node.colour)
	}

}